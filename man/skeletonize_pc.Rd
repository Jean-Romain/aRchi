% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/skeletonize.R
\name{skeletonize_pc}
\alias{skeletonize_pc}
\alias{skeletonize_pc,aRchi-method}
\title{Build the skeleton of a tree point cloud}
\usage{
skeletonize_pc(
  aRchi,
  D = 0.03,
  progressive = TRUE,
  cl_dist = 0.02,
  max_d = 0.05,
  K = 100
)

\S4method{skeletonize_pc}{aRchi}(
  aRchi,
  D = 0.03,
  progressive = TRUE,
  cl_dist = 0.02,
  max_d = 0.05,
  K = 100
)
}
\arguments{
\item{aRchi}{an object of class aRchi containing at least a point cloud}

\item{D}{numeric. The distance of research for point neighborhood. Sets the
layer tickness. See description for details. Default = 0.02}

\item{progressive}{logical. Should the clustering distance be progressive ?
See description for details. Default = TRUE.}

\item{cl_dist}{numeric. The clustering distance. If \code{pregressive = FALSE}
sets the clustering distance for all the point cloud. If \code{pregressive = TRUE}
sets the minimum clustering distance to be used. See description for details.
Default = 0.02.}

\item{max_d}{The maximum searching distance for skeleton building. See
description for details.Default = 0.05.}

\item{K}{The number of points for neighboor searching. See description for
details. Default = 100.}
}
\value{
an aRchi file containing the original point cloud and the corresponding skeleton
}
\description{
The skeletonization algorithm works in four steps. At STEP 1 the
point cloud is divided in layers of regular thickness (defined by parameter
\code{D}). To do so, the tree base is fisrt defined as first layer and all the points
of the point cloud that are within \code{D} of any points of the layer are defined
as the next layer. This process continues until that no more points are found.
If there are some remaining points (that are further than \code{D} to any
classifyed points),a new layer is defined as the point that is the closer of
the already classified point within the layer produced at earliest iteration.
This continues until no more points remain unclassified. at STEP 2, the layers
are devided into clusters based on point distance: two point that are further
than a given distance are considered as being part of two different objects.
Two possibilities are available to define the clustering distance. First, it
remains constant and is defined by \code{cl_dist}. Second, the distance is
defined as the average distance of the points of the previous layer to the
center of their corresponding layer (this is achieved by setting
\code{progressive = TRUE}). In this case, \code{cl_dist} defines the minimal
clustering distance that can be used. This option helps to adapt the clustering
distance to the size of the actual obtects (i.e. branch sections) to cluster.
By default the first layer is assumed as being part of a single cluster. At
STEP 3, the cluster centers are combined to build the skeleton. To do so, an
iterative and hierarchical process starting with a starting point defined as
the cluster center with the smallest Z value is used. A cluster is automatically
conected to its nearest neighbor located within \code{max_d}. If no neighbour is
detected (because the cluster is a branch tip or due to occlusion), the process
restarts with the cluster located in the earliest layer that is the closer to
an already used cluster as new starting point. This process ends once all cluster
centers are connected.
}
\examples{
\donttest{
# import a point cloud
tls=system.file("extdata","Tree_2_point_cloud.las",package = "aRchi")
tls = lidR::readLAS(tls)

# build an empty aRchi file and add the point cloud
aRchi = aRchi::build_aRchi()
aRchi = aRchi::add_pointcloud(aRchi,point_cloud = tls)

# plot the point cloud
plot(aRchi@pointcloud)

# build a skeleton from the point cloud
aRchi = skeletonize_pc(aRchi)

# smooth the skeleton
aRchi = smooth_skeleton(aRchi)

# plot the skeleton
plot(aRchi,show_point_cloud = TRUE)
}
}
